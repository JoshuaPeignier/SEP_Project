(* declaring a free channel name *)
free c:channel.

(* declaring additional types; type bitstring is a default type *)
type key.


(* declaring private names *)
free k_im, k_rm:key [private]. 

(* Public key cryptography *)
fun senc(bitstring, key):bitstring. 	(* symmetric encryption *)
fun sdec(bitstring, key):bitstring.	(* symmetric decryption *)
fun h(bitstring):bitstring.		(* hash function *)

(* equational theory for pk encryption *)
equation forall x:bitstring, y:key; sdec(senc(x,y),y) = x.

(* events *)
	(* declare events here *)
	event reach.
	event acceptI(key, key, key, bitstring).
	event acceptR(key, key, key, bitstring).
	event startR(key, key, key, bitstring).
	event startI(key, key, key, bitstring).

(* queries *)
	(* fill in queries here *)
	query event(reach).
	(* query attacker(new nb[ pki = pk(ska)]) *) (* tests the secrecy of nb in runs where pki = pk(ska) *)
	(* query attacker(new na). *)
	(* query attacker(new nb). *)
	query x:key, y:bitstring ; event(acceptI(k_im,k_rm,x,y)) ==> event(startR(k_im,k_rm,x,y)). 
	query x:key, y:bitstring ; event(acceptR(k_im,k_rm,x,y)) ==> event(startI(k_im,k_rm,x,y)).      

(* initiator process *)
let Pi(ki:key, kr:key) = 
	 new k:key; 
	 out(c, senc((k,kr), ki));
	 in(c, x:bitstring);
	 let (n:bitstring) = sdec(x, k) in 
	 event startI(ki,kr,k,n);
	 out(c, h(n));
	 event acceptI(ki,kr,k,n).
	 

(* responder process *)
let Pr (kr:key)= in(c, x:bitstring);
		  let (ki:key , k:key) = sdec(x, kr) in
		  new n:bitstring;
		  event startR(ki,kr,k,n);
		  out(c, senc(n,k) );
		  in(c, y:bitstring);
		  let (=h(n)) = y in 
		  event reach;
		  event acceptR(ki,kr,k,n).


(* server process *)
let Pm (ki:key) = in(c, x:bitstring);
	 	  let (k:key , kr:key) = sdec(x,ki) in
		  out(c, senc((ki,k),kr)).


(* main process *)
process  ( Pi(k_im,k_rm) | Pr(k_rm) | Pm(k_im) )
(* process ( ! Pi(ska, pk(skc)) | ! Pi(ska, pk(skb)) | ! Pi(skb, pk(ska)) | ! Pi(skb, pk(skc)) | ! Pr(ska) | ! Pr(skb) | out(c,pk(ska)) | out(c, pk(skb)) | out(c, skc)  ) *)

