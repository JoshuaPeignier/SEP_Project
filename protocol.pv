(* declaring a free channel name *)
free c:channel.

(* declaring additional types; type bitstring is a default type *)
type key.
type identity.

(* declaring private names *)
free k_im, k_rm:key [private]. 

(* Public key cryptography *)
fun senc(bitstring, key):bitstring. 	(* symmetric encryption *)
fun sdec(bitstring, key):bitstring.	(* symmetric decryption *)
fun h(bitstring):bitstring.		(* hash function *)
fun id(key):identity.


(* equational theory for pk encryption *)
equation forall x:bitstring, y:key; sdec(senc(x,y),y) = x.

(* events *)
	(* declare events here *)
	event reach.
	event acceptI(identity, identity, key, bitstring).
	event acceptR(identity, identity, key, bitstring).
	event startR(identity, identity, key, bitstring).
	event startI(identity, identity, key, bitstring).

(* queries *)
	(* fill in queries here *)
	query event(reach).
	(* query attacker(new nb[ pki = pk(ska)]) *) (* tests the secrecy of nb in runs where pki = pk(ska) *)
	query attacker(new k).
	query attacker(new n).
	query x:key, y:bitstring ; event(acceptI(id(k_im),id(k_rm),x,y)) ==> event(startR(id(k_im),id(k_rm),x,y)). 
	query x:key, y:bitstring ; event(acceptR(id(k_im),id(k_rm),x,y)) ==> event(startI(id(k_im),id(k_rm),x,y)).      

(* initiator process *)
let Pi(ki:key, r:identity) = 
	 new k:key; 
	 out(c, senc((k,r), ki));
	 in(c, x:bitstring);
	 let (n:bitstring) = sdec(x, k) in 
	 event startI(id(ki),r,k,n);
	 out(c, h(n));
	 event acceptI(id(ki),r,k,n).
	 

(* responder process *)
let Pr (kr:key)= in(c, x:bitstring);
		  let (i:identity , k:key) = sdec(x, kr) in
		  new n:bitstring;
		  event startR(i,id(kr),k,n);
		  out(c, senc(n,k) );
		  in(c, y:bitstring);
		  let (=h(n)) = y in 
		  event reach;
		  event acceptR(i,id(kr),k,n).


(* server process *)
let Pm (ki:key,kr:key) = in(c, x:bitstring);
	 	  let (k:key , =id(kr)) = sdec(x,ki) in
		  out(c, senc((id(ki),k),kr)).


(* main process *)
process  ( Pi(k_im, id(k_rm)) | Pr(k_rm) | Pm(k_im,k_rm) )
(* process ( ! Pi(ska, pk(skc)) | ! Pi(ska, pk(skb)) | ! Pi(skb, pk(ska)) | ! Pi(skb, pk(skc)) | ! Pr(ska) | ! Pr(skb) | out(c,pk(ska)) | out(c, pk(skb)) | out(c, skc)  ) *)

